Concurrency bugs which are often resident in multi-threaded programs with shared memory designs are difficult to find and reproduce. 
Deterministic multi-threading (DMT) is one such scheme indicated to resolve the above difficulty. 
But, DMT presents the challenge of having no scheduling constraints.  
However, currently there are no such techniques that allow to control the schedule of a multi-threaded program on a fine-grained level, i.e, on the level of single memory accesses. 
A design with a granularity of single memory accesses would help in enforcing the scheduling constraint. 
This thesis focuses on moving the scheduling decision to kernel space. 
Thus, improving the execution time of the user program.

In the existing design, we have a thread scheduler and a verification engine.  
The verification engine primarily focuses on instrumenting the user code and realizing memory accesses made by various user threads. 
The set of safe schedules are provided by the verification engine for the given user program. 
The generated execution pattern is later realized with the thread scheduler, when the user program is executed. 
The scheduler thread is realized in user space. 
However, there is a problem of the scheduler thread getting context switched when executed in user space. 
The operating system scheduler might ignore the scheduling constraint set by the user level scheduler. 
Moving the scheduler task to the kernel space would help to realize the safe scheduling constraints set by the user. 
With the migration of scheduler module to the kernel space, there arises certain design changes and challenges. 

The approach used in the thesis would be bench-marked on various benchmarking programs such as Indexer, Last Zero, Fibonacci and Dining Philosopher's Problem.  
The evaluation is performed on the execution overhead exerted by the transition to a loadable kernel module. 
The evaluation will also relate to the number of synchronizations taking place when using the ioctl calls. 
The above comparison would also cover evaluations across instrumented and un-instrumented code. 
The scaling of thread count to core count is also considered for the above evaluations. 
The approach presented in this work is expected to reduce the execution overhead and also some shortcomings generated by its counterpart user-space design. 