Concurrency bugs which are often resident in multi-threaded programs with shared memory designs are difficult to find and reproduce. 
Deterministic multi-threading (DMT) is one such scheme indicated to resolve the above difficulty. 
But, DMT presents the challenge of having no scheduling constraints.  
However, currently there are no such techniques that allow to control the schedule of a multi-threaded program on a fine-grained level, i.e, on the level of single memory accesses. 
A design with a granularity of single memory accesses would help in enforcing the scheduling constraint. 
This thesis focuses on moving the scheduling decision to kernel space. 
Thus, improving the execution time of the user program.


In the existing design, we have a thread scheduler and a verification engine.  
The verification engine primarily focuses on instrumenting the user code and realizing memory accesses made by various user threads. 
The set of safe schedules are provided by the verification engine for the given user program. 
The generated execution pattern is later realized with the thread scheduler, when the user program is executed. 
The scheduler thread is realized in user space. 
It is realized in two design modes - separate thread and shared thread. 
However, there is a problem of the scheduler thread getting context switched when executed in user space. 
Considering the example from above, the operating system scheduler might ignore the scheduling constraint set by the user level scheduler. 
Moving the scheduler task to the kernel space would help to realize the safe scheduling constraints set by the user. 

With the migration of scheduler module to the kernel space, there arises certain design changes and challenges. 
By overcoming the additional synchronization overhead existent in the user space design, we encounter the problem of invoking system calls for accessing the kernel module. 
In a monolithic kernel architecture, most of the system calls are blocking synchronous calls to the kernel space. 
Having too many system calls would increase the scheduler overhead on the program execution. 
One solution is to make system calls when there is an imminent context switch (expected thread switch in the provided safe schedule). 
The user space threads would assess the safe schedules or traces based on which the system calls for the kernel space scheduler would be made. 


The approach used in the thesis would be benchmarked on various thread conditional scenarios such as indexer, last zero, fibonacci and dining philosophers problem. 
These programs enforce the verification of correctness in multi-threaded environment. 
The evaluation is performed on the execution overhead exerted by the transition to the LKM. 
The evaluation will also relate to the number of synchronizations taking place when using the system calls. 
Additionally, a comparison of execution overhead generated by other designs PARROT, CORE-DET are also considered for the above mentioned benchmarking programs. 
The above comparison would also cover evaluations across instrumented and un-instrumented code. 
The scaling of thread count to core count is also considered for the above evaluations.
Thus, creating a possibility of false sharing situations and various other potential execution overhead conditions. 
