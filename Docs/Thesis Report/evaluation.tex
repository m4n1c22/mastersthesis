In this chapter, we provide an evaluation proof of using IRS in kernel space. 
All the evaluations are done in regard with the user space implementation. 

\section{Setup}

The evaluation is performed on a virtual machine running on cluster with a maximum of 128 cores. 
The virtual machine can use from two to eight processor cores which is used for the scaled up evaluation. 
The virtual machine is based on Intel Xeon Family of processors configured with Ubuntu 16.10 as the operating system. 
It is configured with 4GB RAM and 80GB hard disk. 
The virtual machine is configured with the LLVM-CLANG 3.9.


\section{Evaluation Metrics}

\begin{itemize}
\item{Execution Overhead} - Evaluation is done between the IRS user space solution vs kernel space solution. 
Execution overhead generated by either of the designs with respect to the un-instrumented execution is used as an evaluation criteria.
\item{Number of valid synchronization calls} - It is used to realize the number of voluntary calls made to kernel space for synchronization purposes. 
It is primarily the number of IOCTL calls under the command - context\_switch, signal\_all\_other\_threads or set\_clock.
\end{itemize}


\section{Benchmarks}

We use four different benchmarking programs for the evaluation of this thesis. 
The benchmarking programs include:
\begin{itemize}
\item{Fibonacci} - Program runs with two threads computing fibonacci numbers for 25 iterations per thread.
\item{Last Zero} - Program runs with 16 threads~\citep{abdulla2014optimal}.
\item{Indexer}- Program runs with 15 threads~\citep{dynamic_por}.
\item{Dining Philosophers Problem} - Program runs with 16 threads. These threads are classified as odd and even philosophers thread. 
In this benchmark, only one class of philosopher thread is active at any point of time. 
This benchmark is motivated from the solution presented in \citet{silberschatz2014operating}.
\end{itemize}

\section{Voluntary kernel level calls}

We evaluate the number of voluntary calls made to kernel space for synchronization. 
The evaluation is done across all six prototypes. 
The benchmark used for the evaluation is Fibonacci.

\section{Scaled-up Evaluation}

In this evaluation, we understand the merits and demerits in the performance of the realized prototypes and the two user space IRS implementation. 
For this evaluation, we use 3 benchmarking programs -last zero, indexer and dining philosphers problem. 